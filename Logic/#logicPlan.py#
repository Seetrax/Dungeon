[O# our own logic file. 

"""
In logicPlan.py, you will implement logic planning methods.
"""

from logic import conjoin, disjoin
from logic import PropSymbolExpr, Expr, to_cnf, pycoSAT, parseExpr, pl_true

# Expr class is in logic.py . 

# QUESTION 1 ------------------------------------------------------------

def sentence1() -> Expr:
    """Returns a Expr instance that encodes that the following expressions are all true.
    
    A or B
    (not A) if and only if ((not B) or C)
    (not A) or (not B) or C
    """
    "*** BEGIN YOUR CODE HERE ***"

    """Write the sentences and then return them conjoined"""

    A = Expr("A")
    B = Expr("B")
    C = Expr("C")

    a_or_b = disjoin(A, B)
    expr2 = ~A % disjoin(~B, C)
    expr3 = disjoin(~A, ~B, C)

    return conjoin(a_or_b, expr2, expr3)
    "*** END YOUR CODE HERE ***"

def sentence2() -> Expr:
    """Returns a Expr instance that encodes that the following expressions are all true.
    
    C if and only if (B or D)
    A implies ((not B) and (not D))
    (not (B and (not C))) implies A
    (not D) implies C
    """
    "*** BEGIN YOUR CODE HERE ***"

    """Write the sentences and then return them conjoined"""

    A = Expr("A")
    B = Expr("B")
    C = Expr("C")
    D = Expr("D")

    expr1 = C % disjoin(B, D)
    expr2 = A >> conjoin(~B, ~D)
    expr3 = ~conjoin(B, ~C) >> A
    expr4 = ~D >> C

    return conjoin(expr1, expr2, expr3, expr4)
    "*** END YOUR CODE HERE ***"

def sentence3() -> Expr:
    """Using the symbols BaahubaliAlive_1 BaahubaliAlive_0, BaahubaliBorn_0, and BaahubaliKilled_0,
    created using the PropSymbolExpr constructor, return a PropSymbolExpr
    instance that encodes the following English sentences (in this order):

    Baahubali is alive at time 1 if and only if Baahubali was alive at time 0 and it was
    not killed at time 0 or it was not alive at time 0 and it was born at time 0.

    Baahubali cannot both be alive at time 0 and be born at time 0.

    Baahubali is born at time 0.
    (Project update: for this question only, [0] and _t are both acceptable.)
    """
    "*** BEGIN YOUR CODE HERE ***"

    """Make the sentences that are described and return them conjoined"""

    BaahubaliAlive_0 = PropSymbolExpr("BaahubaliAlive", 0)
    BaahubaliAlive_1 = PropSymbolExpr("BaahubaliAlive", 1)
    BaahubaliBorn_0 = PropSymbolExpr("BaahubaliBorn", 0)
    BaahubaliKilled_0 = PropSymbolExpr("BaahubaliKilled", 0)

    expr1 = BaahubaliAlive_1 % disjoin(conjoin(BaahubaliAlive_0, ~BaahubaliKilled_0), conjoin(~BaahubaliAlive_0, BaahubaliBorn_0))
    expr2 = ~conjoin(BaahubaliAlive_0, BaahubaliBorn_0)
    expr3 = BaahubaliBorn_0

    return conjoin(expr1, expr2, expr3)
    "*** END YOUR CODE HERE ***"

def findModel(sentence: Expr) -> Dict[Expr, bool]:
    """Given a propositional logic sentence (i.e. a Expr instance), returns a satisfying
    model if one exists. Otherwise, returns False.
    """
    cnf_sentence = to_cnf(sentence)
    return pycoSAT(cnf_sentence)

def entails(premise: Expr, conclusion: Expr) -> bool:
    """Returns True if the premise entails the conclusion and False otherwise.
    """
    "*** BEGIN YOUR CODE HERE ***"
    
    """If findModel doesn't find any model where the premise & not(conxlusion) is satisfiable return False"""

    return findModel(premise & ~conclusion) == False
    "*** END YOUR CODE HERE ***"

def plTrueInverse(assignments: Dict[Expr, bool], inverse_statement: Expr) -> bool:
    """Returns True if the (not inverse_statement) is True given assignments and False otherwise.
    pl_true may be useful here; see logic.py for its description.
    """
    "*** BEGIN YOUR CODE HERE ***"
    return pl_true(~inverse_statement, assignments)
    "*** END YOUR CODE HERE ***"

# QUESTION2 ------------------------------------------------------------------------

def atLeastOne(literals: List[Expr]) -> Expr:
    """
    Given a list of Expr literals (i.e. in the form A or ~A), return a single 
    Expr instance in CNF (conjunctive normal form) that represents the logic 
    that at least one of the literals  ist is true.
    >>> A = PropSymbolExpr('A');
    >>> B = PropSymbolExpr('B');
    >>> symbols = [A, B]
    >>> atleast1 = atLeastOne(symbols)
    >>> model1 = {A:False, B:False}
    >>> print(pl_true(atleast1,model1))
    False
    >>> model2 = {A:False, B:True}
    >>> print(pl_true(atleast1,model2))
    True
    >>> model3 = {A:True, B:True}
    >>> print(pl_true(atleast1,model2))
    True
    """
    "*** BEGIN YOUR CODE HERE ***"
    return disjoin(literals)
    "*** END YOUR CODE HERE ***"


def atMostOne(literals: List[Expr]) -> Expr:
    """
    Given a list of Expr literals, return a single Expr instance in 
    CNF (conjunctive normal form) that represents the logic that at most one of 
    the expressions in the list is true.
    itertools.combinations may be useful here.
    """
    "*** BEGIN YOUR CODE HERE ***"

    """Take all the combinations of 2 literals and disjoin them with not"""

    combinations = itertools.combinations(literals, 2)
    clauses_list = []
    for combo in combinations:
        clauses_list.append(disjoin(~combo[0], ~combo[1])) 
    
    return conjoin(clauses_list)
    "*** END YOUR CODE HERE ***"


def exactlyOne(literals: List[Expr]) -> Expr:
    """
    Given a list of Expr literals, return a single Expr instance in 
    CNF (conjunctive normal form)that represents the logic that exactly one of 
    the expressions in the list is true.
    """
    "*** BEGIN YOUR CODE HERE ***"
    # Use the previous functions
    return conjoin(atLeastOne(literals), atMostOne(literals))
    "*** END YOUR CODE HERE ***"

